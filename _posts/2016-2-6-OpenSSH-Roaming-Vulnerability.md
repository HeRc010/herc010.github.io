---
layout: post
category: vulnerabilities and exploits
title: "Recently Discovered Vulnerability in the OpenSSH Roaming Feature"
tagline: ""
tags : [vulnerability, exploit, OpenSSH]
---
{% include JB/setup %}

## TL;DR

A recently discovered OpenSSH vulnerability had the potential to afford the malicious acquisition of private SSH key fragments.

## Overview

A vulnerability concerning the OpenSSH roaming feature was recently discovered and analyzed by Qualys, the consequence of which could allow an attacker to obtain private SSH key information from a Client [1].

The potential for exploitation was based on two factors:

- The Client application relies on a Server-provided value which determines the number of bytes which must be resent to the Server, in the advent of a loss in connection between the Client and Server.
- The Client application utilizes allocated memory which may contain lingering values from previous usage of the same memory.


## The Exploit

The roaming feature is intended to facilitate the seamless reconnection between a Client and Server in the event of disruptive variance in connection quality. The Client stores data that has been sent to a Server, which may not have yet been received by the Server, in a buffer. In the event that an unexpected interruption in connectivity occurs between the Client and Server, the Server may request that a certain number of bytes be resent. However a Server being used for malicious intent could trigger a disconnection and upon reconnection request that more bytes be resent than were originally sent. The potential result is the acquisition of the entire buffer being utilized by the Client, which may contain private SSH key information which has not been cleared from memory.

Oversight was in place to clear the memory used to store sensitive information, specifically the use of memset() and bzero() was exercised. However these operations were optimized away by some compilers, including Clang/LLVM and GCC 5 which use "Dead Store Elimination‚Äù to remove store operations which operate on memory which is never read again. A change introduced to remedy this issue is the usage of explicit_bzero() to prevent such optimizations in specific areas of the application.

A principle factor resulting in the acquisition of the private key information was the use of standard I/O operations in C, specifically invocations to fopen() and supporting functions. fopen() is utilized to read the key files from the .ssh directory of a user, the content of which is stored in an internally allocated buffer. On Linux systems, the use of the GNU C library effectively ensures that the contents of the buffer are cleared once the buffer is freed, however on BSD based systems the memory is not cleared upon being freed.

As a result there is a significant potential that partial, private SSH key information may linger in the buffer being used by the Client to store information that may not have been successfully delivered to the Server. Consequently the acquisition of the entire buffer from the Client constitutes a significant security vulnerability.

## Summary

These discoveries illustrate the necessity of ensuring that exclusively, fully implemented features are released in software products, in order to ensure that the source code being introduced into releases is effectively exercised during testing. Additionally these discoveries suggest that the dismissal of concerns regarding potential security vulnerabilities based on the belief that the software in question cannot be utilized for malicious intent is unwise.

## Sources

[1] [Lwn.net, "OpenSSH and the dangers of unused code", 2016.](https://lwn.net/Articles/672465/) [Accessed: 06-Feb-2016].
